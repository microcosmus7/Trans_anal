}
hours <- as.numeric(hour_str)  # Convert to numeric
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Hoppers$Hour_cont <- unlist(lapply(Hoppers$Hour, time_to_minutes))
time_to_minutes <- function(time_str) {
hour_str <- substr(time_str, 1, ifelse(nchar(time_str) == 4, 1, 2))  # Extract the hour substring
hours <- as.numeric(hour_str)  # Convert to numeric
minutes <- as.numeric(substr(time_str, nchar(time_str) - 1, nchar(time_str)))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Hoppers$Hour_cont <- unlist(lapply(Hoppers$Hour, time_to_minutes))
time_to_minutes <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
if (nchar(hour_str) == 1) {
hour_str <- paste0("0", hour_str)  # Prepend a leading zero
}
hours <- as.numeric(hour_str)  # Convert to numeric
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Hoppers$Hour_cont <- unlist(lapply(Hoppers$Hour, time_to_minutes))
time_to_minutes <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
if (nchar(hour_str) == 1) {
hour_str <- paste0("0", hour_str)  # Prepend a leading zero
}
hours <- as.numeric(hour_str)  # Convert to numeric
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Hoppers$Hour_cont <- unlist(lapply(Hoppers$Hour, time_to_minutes))
##first convert time to character
Hoppers$Hour_c <- as.character(Hoppers$Hour)
# Apply the function to the 'time' column
Hoppers$Hour_cont <- unlist(lapply(Hoppers$Hour_c, time_to_minutes))
#### Add a column for the order of the eggs within each nest
## first arrange data
Jackou <- Jackou %>%
arrange(idCaixaNiu, julian)
## then add order of eggs based on clutch
Jackou <- Jackou %>%
group_by(idCaixaNiu) %>%
mutate(egg_order = row_number())
Jackou <- Jackou %>%
group_by(idCaixaNiu, julian) %>%
mutate(certainty = ifelse(n() > 1, "uncertain", "certain"))
## Get a CLUTCH SIZE for each nest
Jackou <- Jackou %>%
group_by(idCaixaNiu) %>%
mutate(clutch_size = n_distinct(pes))
## get the NUMBER OF NESTS per tower
Jackou <- Jackou %>%
group_by(idEstructura) %>%
mutate(colony_size = n_distinct(idCaixaNiu))
##
# Sort the data by measurement date
Jackou <- Jackou %>% arrange(idCaixaNiu, julian)
# Group the data by clutch ID
Jackou <- Jackou %>% group_by(idCaixaNiu)
# Calculate laying date for each clutch
Jackou <- Jackou %>%
mutate(laying_date = min(julian))
# Calculate mean laying date for each clutch
Jackou <- Jackou %>%
group_by(idEstructura) %>%
mutate(mean_laying_date = mean(laying_date))
# Calculate synchrony values for each clutch within tower, we see the difference between laying date of the nest (first layed egg) and mean laying date of the whole nesting tower.
Jackou <- Jackou %>%
mutate(synchrony_tower = laying_date - mean_laying_date)
# Calculate synchrony values for each egg within clutch, we see the difference between the laying date of each egg and the mean laying date of the nesting tower.
## maybe I should consider the difference beteween the laying date of each egg and the laying date of the first egg. But it wouldn't make sense if these are layed one per day.
Jackou <- Jackou %>%
mutate(synchrony_nest = julian - mean_laying_date)
View(Jackou)
# Read the TIME sheet into a data frame
Time <- read.csv("Time_arrival.csv", sep=";", stringsAsFactors=TRUE)
# add julian date
Time$dat<- as.Date(Time$data, "%d/%m/%Y")
Time$julian <- as.numeric(format(Time$dat, "%j"))
## filter to get only 2023
Time <- subset(Time, Time$any == 2023)
# Merge the two data frames based on towerID and date
Jackou_t <- merge(Jackou, Time, by = c("julian", "idEstructura"))
## delete columns that are not needed
Jackou_t <- subset(Jackou_t, select = -c(id_Social,any.y,data.y,X,X.1,X.2,X.3,X.4,X.5,X.6,X.7,dat.y))
##first convert time to character
Jackou_t$hora_c <- as.character(Jackou_t$hora)
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Jackou_t$hora_cont <- unlist(lapply(Jackou_t$hora, time_to_minutes))
View(Jackou_t)
# Convert time column to POSIXct format
Jackou_t$hora <- as.POSIXct(Jackou_t$hora, format = "%H:%M")
Jackou_t$hora_c <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
if (nchar(hour_str) == 1) {
time_str <- paste0("0", time_str)  # Prepend a leading zero
}
return(time_str)
}
Jackou_t$hora <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
if (nchar(hour_str) == 1) {
time_str <- paste0("0", time_str)  # Prepend a leading zero
}
return(time_str)
}
Jackou_t$hora <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
ifelse(nchar(hour_str) == 1, paste0("0", time_str), time_str)  # Prepend a leading zero if hour has one digit
}
Jackou_t$hora_c <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
ifelse(nchar(hour_str) == 1, paste0("0", time_str), time_str)  # Prepend a leading zero if hour has one digit
}
# Read the TIME sheet into a data frame
Time <- read.csv("Time_arrival.csv", sep=";", stringsAsFactors=TRUE)
# add julian date
Time$dat<- as.Date(Time$data, "%d/%m/%Y")
Time$julian <- as.numeric(format(Time$dat, "%j"))
## filter to get only 2023
Time <- subset(Time, Time$any == 2023)
# Merge the two data frames based on towerID and date
Jackou_t <- merge(Jackou, Time, by = c("julian", "idEstructura"))
View(Jackou_t)
## delete columns that are not needed
Jackou_t <- subset(Jackou_t, select = -c(id_Social,any.y,data.y,X,X.1,X.2,X.3,X.4,X.5,X.6,X.7,dat.y))
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Jackou_t$hora_cont <- unlist(lapply(Jackou_t$hora, time_to_minutes))
preprocess_time <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
ifelse(nchar(hour_str) == 1, paste0("0", time_str), time_str)  # Prepend a leading zero if hour has one digit
}
View(preprocess_time)
Jackou_t <- Jackou_t %>%
mutate(hora = preprocess_time(hora))
# Read the TIME sheet into a data frame
Time <- read.csv("Time_arrival.csv", sep=";", stringsAsFactors=TRUE)
# add julian date
Time$dat<- as.Date(Time$data, "%d/%m/%Y")
Time$julian <- as.numeric(format(Time$dat, "%j"))
## filter to get only 2023
Time <- subset(Time, Time$any == 2023)
# Merge the two data frames based on towerID and date
Jackou_t <- merge(Jackou, Time, by = c("julian", "idEstructura"))
## delete columns that are not needed
Jackou_t <- subset(Jackou_t, select = -c(id_Social,any.y,data.y,X,X.1,X.2,X.3,X.4,X.5,X.6,X.7,dat.y))
preprocess_time <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
ifelse(nchar(hour_str) == 1, paste0("0", time_str), time_str)  # Prepend a leading zero if hour has one digit
}
Jackou_t <- Jackou_t %>%
mutate(hora_c = preprocess_time(hora))
time_to_minutes <- function(time_str) {
# Preprocess time string to ensure two digits for the hour part
preprocess_time <- function(time_str) {
hour_str <- substr(time_str, 1, 2)  # Extract the hour substring
if (nchar(hour_str) == 1) {
time_str <- paste0("0", time_str)  # Prepend a leading zero
}
return(time_str)
}
# Convert preprocessed time string to minutes past midnight
hour_minutes <- as.numeric(substr(preprocess_time(time_str), 1, 2)) * 60
minutes <- as.numeric(substr(time_str, 4, 5))
total_minutes <- hour_minutes + minutes
return(total_minutes)
}
Jackou_t$hora_c <- time_to_minutes(Jackou_t$hora)
Jackou_t$hora_c <- time_to_minutes(Jackou_t$hora)
Jackou_t <- Jackou_t %>%
mutate(hora_c = time_to_minutes(hora))
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = ifelse(nchar(substr(hora_c, 1, 2)) == 1,  # If hour has one digit
paste0("0", hora_c),  # Add a leading zero
hora_C))  # Otherwise, keep as is
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = ifelse(nchar(substr(hora_c, 1, 2)) == 1,  # If hour has one digit
paste0("0", hora_c),  # Add a leading zero
hora_c))  # Otherwise, keep as is
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = ifelse(nchar(substr(hora_c, 1, 2)) == 1,  # If hour has one digit
paste0("0", hora_c),  # Add a leading zero
hora_c))  # Otherwise, keep as is
View(Jackou_t)
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Jackou_t$hora_cont <- unlist(lapply(Jackou_t$hora_c, time_to_minutes))
print(hora_c)
print(Jackou_t$hora_c)
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = ifelse(nchar(substr(hora_c, 1, 2)) == 1,  # If hour has one digit
ifelse(nchar(hora_c) > 5,  # If time string contains seconds
paste0("0", hora_c),  # Add a leading zero
paste0("0", substr(hora_c, 1, 4))),  # Add a leading zero (without seconds)
ifelse(nchar(hora_c) > 5,  # If time string contains seconds
hora_c,  # Keep as is
substr(hora_c, 1, 5))))  # Keep as is (without seconds)
print(Jackou_t$hora_c)
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = sub("^([0-9]):", "0\\1:", hora_c))  # Add leading zero if hour has one digit
print(Jackou_t$hora_c)
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Jackou_t$hora_cont <- unlist(lapply(Jackou_t$hora_c, time_to_minutes))
View(Jackou_t)
# Convert time column to POSIXct format
Jackou_t$hora_c <- as.POSIXct(Jackou_t$hora_c, format = "%H:%M")
# Define time intervals
intervals <- c(as.POSIXct("07:30", format = "%H:%M"),
as.POSIXct("11:00", format = "%H:%M"),
as.POSIXct("13:00", format = "%H:%M"),
as.POSIXct("15:00", format = "%H:%M"),
as.POSIXct("17:00", format = "%H:%M"),
as.POSIXct("20:00", format = "%H:%M"))
# Define labels for time categories
labels <- c("early_morning", "morning", "midday", "afternoon", "late_afternoon")
# Add a column with time categories
Jackou_t$categoria_hora <- cut(Jackou_t$hora_c, breaks = intervals, labels = labels, right = FALSE)
##first convert time to character
Jackou_t <- Jackou_t %>%
mutate(hora_c = as.character(hora),  # Convert time to character
hora_c = sub("^([0-9]):", "0\\1:", hora_c))  # Add leading zero if hour has one digit
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Jackou_t$hora_cont <- unlist(lapply(Jackou_t$hora_c, time_to_minutes))
View(Jackou_t)
# Define time intervals
intervals <- c(as.POSIXct("07:30", format = "%H:%M"),
as.POSIXct("11:00", format = "%H:%M"),
as.POSIXct("13:00", format = "%H:%M"),
as.POSIXct("15:00", format = "%H:%M"),
as.POSIXct("17:00", format = "%H:%M"),
as.POSIXct("20:00", format = "%H:%M"))
# Define labels for time categories
labels <- c("early_morning", "morning", "midday", "afternoon", "late_afternoon")
# Add a column with time categories
Jackou_t$categoria_hora <- cut(Jackou_t$hora_c, breaks = intervals, labels = labels, right = FALSE)
assign_time_label <- function(time_str) {
if (time_str < "07:30") {
return("before_early_morning")
} else if (time_str >= "07:30" & time_str < "11:00") {
return("early_morning")
} else if (time_str >= "11:00" & time_str < "13:00") {
return("morning")
} else if (time_str >= "13:00" & time_str < "15:00") {
return("midday")
} else if (time_str >= "15:00" & time_str < "17:00") {
return("afternoon")
} else if (time_str >= "17:00" & time_str < "20:00") {
return("late_afternoon")
} else {
return("evening")
}
}
# Apply the custom function to assign labels to time intervals
Jackou_t <- Jackou_t %>%
mutate(categoria_hora = assign_time_label(hora_c))
assign_time_label <- function(time_str) {
ifelse(time_str < "07:30", "before_early_morning",
ifelse(time_str < "11:00", "early_morning",
ifelse(time_str < "13:00", "morning",
ifelse(time_str < "15:00", "midday",
ifelse(time_str < "17:00", "afternoon",
ifelse(time_str < "20:00", "late_afternoon", "evening"))))))
}
# Apply the custom function to assign labels to time intervals
Jackou_t <- Jackou_t %>%
mutate(categoria_hora = assign_time_label(hora_c))
View(Jackou_t)
# see whether time affects egg weight. What should be random? tower and nest. What should be fixed? time
fit <- lmer(pes ~ idEstructura + (1|categoria_hora), data = Jackou_t)
summary(fit)
# see whether time affects egg weight. What should be random? tower and nest. What should be fixed? time
fit <- lmer(pes ~ categoria_hora + (1|idEstructura), data = Jackou_t)
summary(fit)
Hoppers <- read.csv("Hoppers_a.csv", sep=";", stringsAsFactors=TRUE)
# add julian date
Hoppers$dat<- as.Date(Hoppers$Date, "%d/%m/%Y")
Hoppers$julian <- as.numeric(format(Hoppers$dat, "%j"))
## first arrange data
Hoppers <- Hoppers %>%
arrange(Tower, julian)
## summ groups disregarding family and size.
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Orth", names(.))], na.rm = TRUE))
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Lep", names(.))], na.rm = TRUE))
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Col", names(.))], na.rm = TRUE))
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Dip", names(.))], na.rm = TRUE))
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Ant", names(.))], na.rm = TRUE))
Hoppers <- Hoppers %>%
mutate(Orth = rowSums(.[, grepl("^Oth", names(.))], na.rm = TRUE))
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ julian, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$julian,
main = "Total Eggs Measured Per Day",
xlab = "Total Eggs",
ylab = "Frequency",
col = "skyblue",
border = "black")
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
##first convert time to character
Hoppers <- Hoppers %>%
mutate(hora_c = as.character(Hour),  # Convert time to character
hora_c = sub("^([0-9]):", "0\\1:", hora_c))  # Add leading zero if hour has one digit
print(Hoppers$hora_c)
# Function to convert time string to minutes past midnight
time_to_minutes <- function(time_str) {
hours <- as.numeric(substr(time_str, 1, 2))  # Extract hours
minutes <- as.numeric(substr(time_str, 4, 5))  # Extract minutes
total_minutes <- hours * 60 + minutes
return(total_minutes)
}
# Apply the function to the 'time' column
Hoppers$hora_cont <- unlist(lapply(Hoppers$hora_c, time_to_minutes))
View(Hoppers)
assign_time_label <- function(time_str) {
ifelse(time_str < "07:30", "before_early_morning",
ifelse(time_str < "11:00", "early_morning",
ifelse(time_str < "13:00", "morning",
ifelse(time_str < "15:00", "midday",
ifelse(time_str < "17:00", "afternoon",
ifelse(time_str < "20:00", "late_afternoon", "evening"))))))
}
# Apply the custom function to assign labels to time intervals
Hoppers <- Hoppers %>%
mutate(categoria_hora = assign_time_label(hora_c))
View(Hoppers)
assign_time_label <- function(time_str) {
ifelse(time_str < "09:00", "before_early_morning",
ifelse(time_str < "11:00", "early_morning",
ifelse(time_str < "13:00", "morning",
ifelse(time_str < "15:00", "midday"))))
}
# Apply the custom function to assign labels to time intervals
Hoppers <- Hoppers %>%
mutate(categoria_hora = assign_time_label(hora_c))
a <- lme4::glmer.nb(Orth ~ categoria_hora + (1|Tower), data = Hoppers)
summary(a)
a <- lme4::glmer.nb(Orth ~ categoria_hora + julian + (1|Tower), data = Hoppers)
summary(a)
Hopper$period <- Hopper$julian
Hoppers$period <- Hoppers$julian
Hoppers$period <- ifelse((Hoppers$julian>=120&Hoppers$julian<=125), 'A', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>=125&Hoppers$julian<=135), 'B', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>=135&Hoppers$julian<=145), 'C', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>=146&Hoppers$julian<=155), 'D', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>=155&Hoppers$julian<=165), 'E', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>=165&Hoppers$julian<=175), 'F', Hoppers$period)
a <- lme4::glmer.nb(Orth ~ categoria_hora + julian + (1|Tower), data = Hoppers)
a <- lme4::glmer.nb(Orth ~ categoria_hora + period + (1|Tower), data = Hoppers)
summary(a)
b <- lme4::glmer.nb(Orth ~ categoria_hora + (1|Tower), data = Hoppers)
AIC(a,b)
c <- lme4::glmer.nb(Orth ~ categoria_hora * period + (1|Tower), data = Hoppers)
AIC(a,b,c)
summary(c)
a <- lme4::glmer.nb(Orth ~ categoria_hora + (1|Tower), data = Hoppers)
b <- lme4::glmer.nb(Orth ~ categoria_hora + period + (1|Tower), data = Hoppers)
c <- lme4::glmer.nb(Orth ~ categoria_hora * period + (1|Tower), data = Hoppers)
AIC(a,b,c)
summary(c)
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ period, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$period,
main = "Total Eggs Measured Per Day",
xlab = "Total Eggs",
ylab = "Frequency",
col = "skyblue",
border = "black")
# Create barplot
barplot(total$Orth,names.arg = total$period,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
# Create barplot
barplot(total$Orth,names.arg = total$julian,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ period, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$julian,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ period, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$julian,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ julian, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$julian,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
Hoppers$period <- Hoppers$julian
Hoppers$period <- ifelse((Hoppers$julian<=125), 'A', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>125&Hoppers$julian<=145), 'B', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>145&Hoppers$julian<=165), 'C', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>165&Hoppers$julian<=175), 'D', Hoppers$period)
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ period, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$period,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
a <- lme4::glmer.nb(Orth ~ categoria_hora + (1|Tower), data = Hoppers)
b <- lme4::glmer.nb(Orth ~ categoria_hora + period + (1|Tower), data = Hoppers)
c <- lme4::glmer.nb(Orth ~ categoria_hora * period + (1|Tower), data = Hoppers)
AIC(a,b,c)
c <- lme4::glmer.nb(Orth ~ categoria_hora * period + (1|Tower), data = Hoppers)
summary(c)
Hoppers$period <- Hoppers$julian
Hoppers$period <- ifelse((Hoppers$julian<=125), 'A', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>125&Hoppers$julian<=135), 'B', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>135&Hoppers$julian<=145), 'C', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>145&Hoppers$julian<=155), 'D', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>155&Hoppers$julian<=165), 'E', Hoppers$period)
Hoppers$period <- ifelse((Hoppers$julian>165&Hoppers$julian<=175), 'F', Hoppers$period)
c <- lme4::glmer.nb(Orth ~ categoria_hora * period + (1|Tower), data = Hoppers)
summary(c)
# Aggregate the data by date to get the total abundance per day
total <- aggregate(Orth ~ period, data = Hoppers, FUN = sum)
# Create barplot
barplot(total$Orth,names.arg = total$period,
main = "Orthopter abundance per period",
xlab = "Stage period",
ylab = "Total Orthopter",
col = "skyblue",
border = "black")
